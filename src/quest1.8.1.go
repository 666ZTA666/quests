package main

import (
	"fmt"
	"math"
	"strings"
	"time"
)

func main() {
	var u = int64(math.MaxInt64) * -1
	// начальное значение числа это самое большое отрицательное число для типа int64
	fmt.Printf("Начальное значение числа =%v\nИли %b\n\n", u, u)

	//n := "0" Для метода, который работает со строками были полезны данные о числовом представлении 0, 1 и "-" в битах
	//sn := n[0] //"0" = 48, "1" = 49, "-" = 45

	for { // запускаем в бесконечном цикле нашу функцию, сюда можно передать как bitFunc, так и mytjFunc
		mytjFunc(&u)
	}
}

// работает как часы, но из-за большого количества обработок строк итп тратит иногда чуть больше времени
func mytjFunc(u *int64) *int64 {
	var (
		c int64
		s string
		z bool
		i int
	)
	if u == nil {
		fmt.Println("u == nil")
		return nil
	}
	fmt.Println("Какой по очередности бит поменять? от 1 до 64, где 1 отвечает за значения 0\\1 в 10, а 64 за знак")
	_, err := fmt.Scanln(&i) //Сканим записываем
	if err != nil {
		fmt.Println(err)
		return u
	}
	i = 64 - i // инверируем, так как работа будет со строками, нам нужен индекс символа слева
	if i >= 64 || i < 0 {
		fmt.Println("принимаются числа только от 1 до 64")
		return u
	}

	start := time.Now() // запускаем секундомер
	if i == 0 && *u != 0 {
		*u = -*u
		// в случае если надо поменять знак -  меняем знак.
	} else if i == 0 && *u == 0 {
		// в случае если число 0 и надо поменять знак - ничего не делаем.
	} else {
		//когда разобрали все крайние варианты пришло время работать с тривиальными случаями
		c = 1
		z = *u >= 0              // Z отвечает за знак числа
		s = fmt.Sprintf("%b", u) // S - строковое представление числа в двоичном виде
		if len(s) < 64 && z {    // если длина строки s меньше 64 и число положительно, то добиваем ее нулями
			for len(s) < 64 {
				s = fmt.Sprint(0, s)
			}
		} else if len(s) < 64 && !z {
			// а если число отрицательно и длина строки меньше 64, то мы удаляем минус из начала,
			// добиваем нулями до 63 и прибавляем минус в начало
			s = strings.Trim(s, "-")
			for len(s) < 63 {
				s = fmt.Sprint(0, s)
			}
			s = fmt.Sprint("-", s)
		}
		// теперь возводим 2 в степень i
		for j := 1; j < (64 - i); j++ {
			c *= 2
		}
		// если изначальное число положительно, а i бит\символ в строке это 0,
		//то прибавляем к изначальному числу 2 в степени i.
		//Аналогично и в случае, если число отрициательно, а i бит\символ в строке это 1
		if s[i] == 48 && z == true || s[i] == 49 && z == false {
			*u += c
		} else { // если изначальное число положительно, а i бит\символ в строке это 1,
			// то мы вычитаем из числа i-тую степено 2,
			//аналогично и в случае, если число отрицательно, а i бит\символ в строке это 0
			*u -= c
		}
	}
	// выводим число и время работы.
	fmt.Printf("%b\n%v\n", u, u)
	fmt.Println("время работы функции =", time.Now().Sub(start))
	return u
	// в данном случае мы не столкнемся со значением (1<<64 * -1), так как работаем со строками и числами,
	//а изменение первого бита производится за счет сложения или вычитания из нашего числа единицы.
}
