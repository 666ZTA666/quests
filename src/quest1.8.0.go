package main

import (
	"fmt"
	"math"
	"time"
)

func main() {
	var u = int64(math.MaxInt64) * -1
	// начальное значение числа это самое большое отрицательное число для типа int64
	fmt.Printf("Начальное значение числа =%v\nИли %b\n\n", u, u)
	//n := "0" Для метода, который работает со строками были полезны данные о числовом представлении 0, 1 и "-" в битах
	//sn := n[0] //"0" = 48, "1" = 49, "-" = 45
	for { // запускаем в бесконечном цикле нашу функцию, сюда можно передать как bitFunc, так и mytjFunc
		BitFunc(&u)
	}
}

// работает не совсем идеально, но должна управляться побыстрее
func BitFunc(u *int64) *int64 {
	var (
		i int
	)
	if u == nil {
		fmt.Println("u == nil")
		return nil
	}
	fmt.Println("Какой по очередности бит поменять? от 1 до 64, где 1 отвечает за значения 0\\1 в 10, а 64 за знак")
	_, err := fmt.Scanln(&i) // считываем бит
	if err != nil {
		fmt.Println(err)
		return u
	}
	if i > 64 || i <= 0 { // проверка на значение
		fmt.Println("принимаются числа только от 1 до 64")
		return u
	}
	start := time.Now() // запускаем таймер
	if i == 64 {        // в случае с 64м битом, меняем знак
		*u = -*u
		fmt.Printf("%b\n%v\n", *u, *u)
		fmt.Println(time.Now().Sub(start))
		return u
	}
	// в остальных случаях используем смещение и оператор XOR
	*u ^= 1 << (i - 1)
	fmt.Printf("%b\n%v\n", *u, *u)
	fmt.Println(time.Now().Sub(start))
	return u

	// признаюсь честно, не совсем понимаю что происходит при изменении первого бита,
	//но если правильно понимаю, то в минус у нас на одно число больше, чем в плюс, поэтому есть небольшой
	//"не баг, а фича" и в действительности это правильное решение, но выглядит оно не оч...
}

// Была идея полностью на срезах байт сделать, чтобы каждое число хранилось как срез байт, но стало оч сложно может todo
